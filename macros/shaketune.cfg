########################################
# Shake&Tune Remote Service Macros
########################################
#
# These macros run resonance tests on the printer and upload results
# to a remote Shake&Tune service for analysis. Graphs are generated
# off-printer to avoid CPU/memory limitations on embedded systems.
#
# SETUP:
# 1. Run the shaketune-service Docker container on your local network
# 2. Set SHAKETUNE_HOST and SHAKETUNE_PORT below to match your setup
# 3. Include this file in your printer.cfg
#
# USAGE:
# - SHAKETUNE_SHAPER_REMOTE: Input shaper calibration with graphs
# - SHAKETUNE_BELTS_REMOTE: Belt tension comparison
# - SHAKETUNE_EXCITE_REMOTE: Vibrate at specific frequency for diagnosis
#
# NOTE: These macros use BusyBox curl which requires separate field
# names for file uploads. The service accepts both standard curl
# (files=@...) and BusyBox-compatible (file_a=@..., file_b=@...) formats.
#
########################################

[respond]

[gcode_macro _SHAKETUNE_REMOTE_CONFIG]
description: Configuration for remote Shake&Tune service
# CHANGE THESE to match your Docker host
variable_host: "192.168.1.100"
variable_port: "8080"
variable_printer: "default"
gcode:
  # This macro just holds configuration variables


# Shell command for shaper upload with file wait logic
[gcode_shell_command shaketune_upload_shaper_remote]
command: sh -c '
  HOST="192.168.1.100"
  PORT="8080"
  PRINTER="default"

  FILE_X="/tmp/raw_data_x_x.csv"
  FILE_Y="/tmp/raw_data_y_y.csv"

  echo "Waiting for CSV files to be written..."
  TIMEOUT=30
  COUNT=0
  while [ $COUNT -lt $TIMEOUT ]; do
    SIZE_X=$(wc -c < "$FILE_X" 2>/dev/null || echo 0)
    SIZE_Y=$(wc -c < "$FILE_Y" 2>/dev/null || echo 0)
    if [ "$SIZE_X" -gt 1000000 ] && [ "$SIZE_Y" -gt 1000000 ]; then
      break
    fi
    sleep 1
    COUNT=$((COUNT + 1))
  done

  if [ "$SIZE_X" -gt 1000000 ] && [ "$SIZE_Y" -gt 1000000 ]; then
    RESULT=$(curl POST "http://${HOST}:${PORT}/shaper" \
      -F "file_x=@${FILE_X}" \
      -F "file_y=@${FILE_Y}" \
      -F "printer=${PRINTER}" 2>/dev/null)
    echo "==========================================="
    echo "SHAPER GRAPH: http://${HOST}:${PORT}/results/${PRINTER}/"
    echo "==========================================="
  else
    echo "ERROR: Files not ready after ${TIMEOUT}s"
  fi
'
timeout: 120
verbose: True


# Shell command for belts upload with file wait logic
[gcode_shell_command shaketune_upload_belts_remote]
command: sh -c '
  HOST="192.168.1.100"
  PORT="8080"
  PRINTER="default"

  FILE_A="/tmp/raw_data_axis=1.000,-1.000_a.csv"
  FILE_B="/tmp/raw_data_axis=1.000,1.000_b.csv"

  echo "Waiting for CSV files to be written..."
  TIMEOUT=30
  COUNT=0
  while [ $COUNT -lt $TIMEOUT ]; do
    SIZE_A=$(wc -c < "$FILE_A" 2>/dev/null || echo 0)
    SIZE_B=$(wc -c < "$FILE_B" 2>/dev/null || echo 0)
    echo "A=${SIZE_A} bytes, B=${SIZE_B} bytes"
    if [ "$SIZE_A" -gt 1000000 ] && [ "$SIZE_B" -gt 1000000 ]; then
      echo "Both files ready"
      break
    fi
    sleep 1
    COUNT=$((COUNT + 1))
  done

  if [ "$SIZE_A" -gt 1000000 ] && [ "$SIZE_B" -gt 1000000 ]; then
    TS=$(date +%Y%m%d_%H%M%S)
    echo "Uploading to service..."
    RESULT=$(curl POST "http://${HOST}:${PORT}/belts" \
      -F "file_a=@${FILE_A}" \
      -F "file_b=@${FILE_B}" \
      -F "printer=${PRINTER}" \
      -F "timestamp=${TS}" 2>/dev/null)
    echo "==========================================="
    echo "BELTS GRAPH: http://${HOST}:${PORT}/results/${PRINTER}/${TS}_belts.png"
    echo "==========================================="
  else
    echo "ERROR: Files not ready after ${TIMEOUT}s"
    echo "A: ${SIZE_A} bytes, B: ${SIZE_B} bytes"
  fi
'
timeout: 120
verbose: True


[gcode_macro SHAKETUNE_SHAPER_REMOTE]
description: Run input shaper calibration and generate analysis graph via remote service
gcode:
  {% if printer.toolhead.homed_axes != "xyz" %}
    RESPOND MSG="Homing..."
    G28
  {% endif %}

  # Center the toolhead
  G0 X{printer.toolhead.axis_maximum.x / 2} Y{printer.toolhead.axis_maximum.y / 2} Z50 F6000

  RESPOND MSG="Testing X axis resonances..."
  TEST_RESONANCES AXIS=X OUTPUT=raw_data NAME=x
  M400

  RESPOND MSG="Testing Y axis resonances..."
  TEST_RESONANCES AXIS=Y OUTPUT=raw_data NAME=y
  M400

  RESPOND MSG="Uploading to remote Shake&Tune service..."
  RUN_SHELL_COMMAND CMD=shaketune_upload_shaper_remote

  RESPOND MSG="Analysis complete! Check console for graph URL."


[gcode_macro SHAKETUNE_BELTS_REMOTE]
description: Run belt comparison test and generate analysis graph via remote service
gcode:
  {% set min_freq = params.FREQ_START|default(5)|float %}
  {% set max_freq = params.FREQ_END|default(133.33)|float %}
  {% set hz_per_sec = params.HZ_PER_SEC|default(1)|float %}

  {% if printer.toolhead.homed_axes != "xyz" %}
    RESPOND MSG="Homing..."
    G28
  {% endif %}

  # Center the toolhead
  G0 X{printer.toolhead.axis_maximum.x / 2} Y{printer.toolhead.axis_maximum.y / 2} Z50 F6000

  RESPOND MSG="Testing Belt A (1,-1)..."
  TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data NAME=a FREQ_START={min_freq} FREQ_END={max_freq} HZ_PER_SEC={hz_per_sec}
  M400

  RESPOND MSG="Testing Belt B (1,1)..."
  TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data NAME=b FREQ_START={min_freq} FREQ_END={max_freq} HZ_PER_SEC={hz_per_sec}
  M400

  RESPOND MSG="Uploading to remote Shake&Tune service..."
  RUN_SHELL_COMMAND CMD=shaketune_upload_belts_remote

  RESPOND MSG="Analysis complete! Check console for graph URL."


[gcode_macro SHAKETUNE_EXCITE_REMOTE]
description: Vibrate at a specific frequency to locate resonance sources
gcode:
  {% set frequency = params.FREQUENCY|default(25)|int %}
  {% set duration = params.DURATION|default(10)|int %}
  {% set axis = params.AXIS|default("x")|string|lower %}

  {% if axis == "a" %}
    {% set axis = "1,-1" %}
  {% elif axis == "b" %}
    {% set axis = "1,1" %}
  {% endif %}

  {% if printer.toolhead.homed_axes != "xyz" %}
    RESPOND MSG="Homing..."
    G28
  {% endif %}

  G0 X{printer.toolhead.axis_maximum.x / 2} Y{printer.toolhead.axis_maximum.y / 2} Z50 F6000

  RESPOND MSG="Exciting {axis} axis at {frequency}Hz for {duration}s..."
  TEST_RESONANCES OUTPUT=raw_data AXIS={axis} FREQ_START={frequency - 1} FREQ_END={frequency + 1} HZ_PER_SEC={1 / (duration / 3)}
  M400
  RESPOND MSG="Done."
